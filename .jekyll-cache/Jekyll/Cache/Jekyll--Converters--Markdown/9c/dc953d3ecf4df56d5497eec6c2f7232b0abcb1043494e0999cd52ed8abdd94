I"ê’<p>ä»å…¸å‹çš„å¼€æºåˆ†å¸ƒå¼ç³»ç»Ÿå¦‚ä¸‹ï¼ˆä¸é™äºï¼‰ï¼š</p>

<ul>
  <li>åˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿï¼ˆHDFSã€NFSã€Cephï¼‰</li>
  <li>åˆ†å¸ƒå¼æ•°æ®åº“ï¼ˆMongodbã€Cassandraã€ElasticSearchï¼‰</li>
  <li>åˆ†å¸ƒå¼å¤„ç†æ¡†æ¶ï¼ˆHadoopã€MPIã€Sparkã€Stormï¼‰</li>
  <li>åˆ†å¸ƒå¼è°ƒåº¦å™¨ï¼ˆYARNã€Mesosã€Slurmï¼‰</li>
  <li>åˆ†å¸ƒå¼æ“ä½œç³»ç»Ÿï¼ˆKubernetesã€OpenStackã€OpenShiftï¼‰</li>
</ul>

<p>æ‰¾å‡ºåˆ†åˆ«ç¬¦åˆé›†ä¸­å¼ä½“ç³»ç»“æ„ã€éé›†ä¸­ç»„ç»‡ç»“æ„ã€æ··åˆç»„ç»‡ç»“æ„çš„åˆ†å¸ƒå¼ç³»ç»Ÿï¼Œå¹¶ä»è¿™äº›ç³»ç»Ÿä¸­é€‰æ‹©3âˆ¼4ä¸ªç³»ç»Ÿï¼Œæ‰¾å‡ºå…¶ä¸­èƒ½å¤Ÿä½“ç°åˆ†å¸ƒå¼ç³»ç»Ÿå¯æ‰©å±•æ€§ã€å®¹é”™æ€§çš„ä»£ç ç‰‡æ®µï¼Œå¹¶è§£é‡Šã€‚</p>

<h2 id="glusterfs">GlusterFS</h2>

<ul>
  <li><a href="http://www.gluster.org/">å®˜æ–¹ç½‘ç«™</a></li>
  <li><a href="https://github.com/gluster/glusterfs/">gluster/glusterfs</a></li>
  <li><a href="https://blog.51cto.com/wzlinux/1949441">GlusterFS å­˜å‚¨ç»“æ„åŸç†ä»‹ç»</a></li>
</ul>

<p>GlusterFSï¼ˆGNU ClusterFile Systemï¼‰æ˜¯ä¸€ç§å…¨å¯¹ç§°çš„å¼€æºåˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿï¼Œæ‰€è°“å…¨å¯¹ç§°æ˜¯æŒ‡GlusterFSé‡‡ç”¨å¼¹æ€§å“ˆå¸Œç®—æ³•ï¼Œæ²¡æœ‰ä¸­å¿ƒèŠ‚ç‚¹ï¼Œæ‰€æœ‰èŠ‚ç‚¹å…¨éƒ¨å¹³ç­‰ã€‚ç›¸æ¯”å…¶ä»–åˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿï¼ŒGlusterFSå…·æœ‰é«˜æ‰©å±•æ€§ã€é«˜å¯ç”¨æ€§ã€é«˜æ€§èƒ½ã€å¯æ¨ªå‘æ‰©å±•ç­‰ç‰¹ç‚¹ï¼Œå¹¶ä¸”å…¶æ²¡æœ‰å…ƒæ•°æ®æœåŠ¡å™¨çš„è®¾è®¡ï¼Œè®©æ•´ä¸ªæœåŠ¡æ²¡æœ‰å•ç‚¹æ•…éšœçš„éšæ‚£ã€‚</p>

<p><img src="https://docs.gluster.org/en/latest/images/640px-GlusterFS_Architecture.png" alt="å®˜æ–¹æ¶æ„å›¾" /></p>

<p>ä¸Šå›¾æ˜¯æ¥è‡ªå®˜æ–¹æ–‡æ¡£çš„æ¶æ„ç¤ºæ„å›¾ã€‚å¯ä»¥çœ‹å‡ºï¼Œ<strong>GlusterFSæ˜¯ç¬¦åˆéé›†ä¸­ç»„ç»‡ç»“æ„çš„åˆ†å¸ƒå¼ç³»ç»Ÿ</strong>ã€‚</p>

<p>åœ¨<a href="https://github.com/gluster/glusterfs/blob/master/libglusterfs/src/gfdb/gfdb_data_store.c">glusterfs/libglusterfs/src/gfdb/gfdb_data_store.c</a>çš„ç¬¬77~171è¡Œï¼Œæ‰¾åˆ°äº†ä¸€äº›æ’å…¥/åˆ é™¤èŠ‚ç‚¹ç›¸å…³çš„å‡½æ•°ï¼Œä½“ç°äº†GlusterFSçš„å¯æ‰©å±•æ€§ã€‚</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*Internal Function: Adds connection node to the end of
 * the db connection list.*/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">add_connection_node</span><span class="p">(</span><span class="n">gfdb_conn_node_t</span> <span class="o">*</span><span class="n">_conn_node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">GF_ASSERT</span><span class="p">(</span><span class="n">_conn_node</span><span class="p">);</span>

    <span class="cm">/*Lock the list*/</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_conn_mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gf_msg</span><span class="p">(</span><span class="n">GFDB_DATA_STORE</span><span class="p">,</span> <span class="n">GF_LOG_ERROR</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">LG_MSG_LOCK_LIST_FAILED</span><span class="p">,</span>
               <span class="s">"Failed lock db connection "</span>
               <span class="s">"list %s"</span><span class="p">,</span>
               <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">db_conn_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">db_conn_list</span> <span class="o">=</span> <span class="n">_conn_node</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_conn_node</span><span class="o">-&gt;</span><span class="n">conn_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">db_conn_list</span><span class="o">-&gt;</span><span class="n">conn_list</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*unlock the list*/</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_conn_mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gf_msg</span><span class="p">(</span><span class="n">GFDB_DATA_STORE</span><span class="p">,</span> <span class="n">GF_LOG_ERROR</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">LG_MSG_UNLOCK_LIST_FAILED</span><span class="p">,</span>
               <span class="s">"Failed unlock db "</span>
               <span class="s">"connection list %s"</span><span class="p">,</span>
               <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
        <span class="cm">/*TODO What if the unlock fails.
         * Will it lead to deadlock?
         * Most of the gluster code
         * no check for unlock or destroy of mutex!*/</span>
    <span class="p">}</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*Internal Function:
 * Delete connection node from the list*/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">delete_conn_node</span><span class="p">(</span><span class="n">gfdb_conn_node_t</span> <span class="o">*</span><span class="n">_conn_node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">GF_ASSERT</span><span class="p">(</span><span class="n">_conn_node</span><span class="p">);</span>

    <span class="cm">/*Lock of the list*/</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_conn_mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gf_msg</span><span class="p">(</span><span class="n">GFDB_DATA_STORE</span><span class="p">,</span> <span class="n">GF_LOG_ERROR</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">LG_MSG_LOCK_LIST_FAILED</span><span class="p">,</span>
               <span class="s">"Failed lock on db connection"</span>
               <span class="s">" list %s"</span><span class="p">,</span>
               <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*Remove the connection object from list*/</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IS_THE_ONLY_NODE</span><span class="p">(</span><span class="n">_conn_node</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">db_conn_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">GF_FREE</span><span class="p">(</span><span class="n">_conn_node</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IS_FIRST_NODE</span><span class="p">(</span><span class="n">db_conn_list</span><span class="p">,</span> <span class="n">_conn_node</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">db_conn_list</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">db_conn_list</span><span class="o">-&gt;</span><span class="n">conn_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
                                      <span class="n">gfdb_conn_node_t</span><span class="p">,</span> <span class="n">conn_list</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_conn_node</span><span class="o">-&gt;</span><span class="n">conn_list</span><span class="p">);</span>
        <span class="n">GF_FREE</span><span class="p">(</span><span class="n">_conn_node</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*Release the list lock*/</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">db_conn_mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gf_msg</span><span class="p">(</span><span class="n">GFDB_DATA_STORE</span><span class="p">,</span> <span class="n">GF_LOG_WARNING</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">LG_MSG_UNLOCK_LIST_FAILED</span><span class="p">,</span>
               <span class="s">"Failed unlock on db "</span>
               <span class="s">"connection list %s"</span><span class="p">,</span>
               <span class="n">strerror</span><span class="p">(</span><span class="n">ret</span><span class="p">));</span>
        <span class="cm">/*TODO What if the unlock fails.
         * Will it lead to deadlock?
         * Most of the gluster code
         * no check for unlock or destroy of mutex!*/</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>åœ¨<a href="https://github.com/gluster/glusterfs/blob/master/xlators/cluster/dht/src/dht-inode-read.c">glusterfs/xlators/cluster/dht/src/dht-inode-read.c</a>ä¸‹ï¼Œæ‰¾åˆ°å¦‚ä¸‹ä»£ç ï¼ˆ766è¡Œ~784è¡Œï¼‰ï¼š</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">dht_flush</span><span class="p">(</span><span class="n">call_frame_t</span> <span class="o">*</span><span class="n">frame</span><span class="p">,</span> <span class="n">xlator_t</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">fd_t</span> <span class="o">*</span><span class="n">fd</span><span class="p">,</span> <span class="n">dict_t</span> <span class="o">*</span><span class="n">xdata</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">xlator_t</span> <span class="o">*</span><span class="n">subvol</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">op_errno</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">dht_local_t</span> <span class="o">*</span><span class="n">local</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">VALIDATE_OR_GOTO</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
    <span class="n">VALIDATE_OR_GOTO</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
    <span class="n">VALIDATE_OR_GOTO</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>

    <span class="n">local</span> <span class="o">=</span> <span class="n">dht_local_init</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">GF_FOP_FLUSH</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">op_errno</span> <span class="o">=</span> <span class="n">ENOMEM</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">subvol</span> <span class="o">=</span> <span class="n">local</span><span class="o">-&gt;</span><span class="n">cached_subvol</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">subvol</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">gf_msg_debug</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"no cached subvolume for fd=%p"</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
        <span class="n">op_errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">xdata</span><span class="p">)</span>
        <span class="n">local</span><span class="o">-&gt;</span><span class="n">xattr_req</span> <span class="o">=</span> <span class="n">dict_ref</span><span class="p">(</span><span class="n">xdata</span><span class="p">);</span>

    <span class="n">local</span><span class="o">-&gt;</span><span class="n">call_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">STACK_WIND</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">dht_flush_cbk</span><span class="p">,</span> <span class="n">subvol</span><span class="p">,</span> <span class="n">subvol</span><span class="o">-&gt;</span><span class="n">fops</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span>
               <span class="n">local</span><span class="o">-&gt;</span><span class="n">xattr_req</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
    <span class="n">op_errno</span> <span class="o">=</span> <span class="p">(</span><span class="n">op_errno</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">errno</span> <span class="o">:</span> <span class="n">op_errno</span><span class="p">;</span>
    <span class="n">DHT_STACK_UNWIND</span><span class="p">(</span><span class="n">flush</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">op_errno</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>è¿™ä¸ªå‡½æ•°æ˜¯ç”¨äºå¤šèŠ‚ç‚¹é—´æ•°æ®çš„åŒæ­¥åˆ·æ–°ã€‚å¯ä»¥çœ‹åˆ°ï¼Œä»£ç ä¸­ä¼šåœ¨è¿è¡Œé‡åˆ°æ•…éšœæ—¶ç»™å‡ºæŠ¥é”™ä¿¡æ¯å¹¶è·³è½¬<code class="language-plaintext highlighter-rouge">DHT_STACK_UNWIND</code>å‡½æ•°åšä¸‹ä¸€æ­¥å¤„ç†ï¼Œå…·æœ‰ä¸€å®šå®¹é”™æ€§ã€‚</p>

<h2 id="slurm">Slurm</h2>

<p>SLURM ï¼ˆSimple Linux Utility for Resource Managementï¼‰æ˜¯ä¸€ç§å¯ç”¨äºå¤§å‹è®¡ç®—èŠ‚ç‚¹é›†ç¾¤çš„é«˜åº¦å¯ä¼¸ç¼©å’Œå®¹é”™çš„é›†ç¾¤ç®¡ç†å™¨å’Œä½œä¸šè°ƒåº¦ç³»ç»Ÿï¼Œè¢«ä¸–ç•ŒèŒƒå›´å†…çš„è¶…çº§è®¡ç®—æœºå’Œè®¡ç®—é›†ç¾¤å¹¿æ³›é‡‡ç”¨ã€‚SLURM ç»´æŠ¤ç€ä¸€ä¸ªå¾…å¤„ç†å·¥ä½œçš„é˜Ÿåˆ—å¹¶ç®¡ç†æ­¤å·¥ä½œçš„æ•´ä½“èµ„æºåˆ©ç”¨ã€‚å®ƒä»¥ä¸€ç§å…±äº«æˆ–éå…±äº«çš„æ–¹å¼ç®¡ç†å¯ç”¨çš„è®¡ç®—èŠ‚ç‚¹ï¼ˆå–å†³äºèµ„æºçš„éœ€æ±‚ï¼‰ï¼Œä»¥ä¾›ç”¨æˆ·æ‰§è¡Œå·¥ä½œã€‚SLURM ä¼šä¸ºä»»åŠ¡é˜Ÿåˆ—åˆç†åœ°åˆ†é…èµ„æºï¼Œå¹¶ç›‘è§†ä½œä¸šè‡³å…¶å®Œæˆã€‚å¦‚ä»Šï¼ŒSLURM å·²ç»æˆä¸ºäº†å¾ˆå¤šæœ€å¼ºå¤§çš„è¶…çº§è®¡ç®—æœºä¸Šä½¿ç”¨çš„é¢†å…ˆèµ„æºç®¡ç†å™¨ï¼Œå¦‚å¤©æ²³äºŒå·ä¸Šä¾¿ä½¿ç”¨äº† SLURM èµ„æºç®¡ç†ç³»ç»Ÿã€‚</p>

<p><img src="https://slurm.schedmd.com/arch.gif" alt="Slurmæ¶æ„" /></p>

<p>ä¸Šå›¾ä¸ºSlurmæ¶æ„å›¾ã€‚å¯ä»¥çœ‹å‡ºï¼ŒSlurmæ˜¯å…¸å‹çš„<strong>é›†ä¸­å¼ä½“ç³»ç»“æ„</strong>ï¼Œæœ‰å…·ä½“çš„è°ƒåº¦èŠ‚ç‚¹ã€‚</p>

<p>åœ¨Slurmçš„Githubä»“åº“ä¸­ï¼Œæ‰¾åˆ°äº†Slurmä¸­æ›´æ–°èŠ‚ç‚¹çš„ç›¸å…³ä»£ç <a href="https://github.com/SchedMD/slurm/blob/master/src/scontrol/update_node.c">slurm/src/scontrol/update_node.c</a>ï¼Œä¸‹é¢æˆªå–54è¡Œå¼€å§‹çš„è‹¥å¹²è¡Œï¼š</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span>
<span class="nf">scontrol_update_node</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">update_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">update_node_msg_t</span> <span class="n">node_msg</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">reason_str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">,</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tag_len</span><span class="p">,</span> <span class="n">val_len</span><span class="p">;</span>

	<span class="n">slurm_init_update_node_msg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_msg</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="sc">'='</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tag_len</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">val</span><span class="o">++</span><span class="p">;</span>
			<span class="n">val_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">exit_code</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">error</span><span class="p">(</span><span class="s">"Invalid input: %s  Request aborted"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

</code></pre></div></div>

<p>åŒæ—¶ï¼Œåœ¨<a href="https://github.com/SchedMD/slurm/blob/master/src/slurmctld/ping_nodes.c">src/slurmctld/ping_nodes.c</a>çš„127è¡Œå¤„ï¼Œä¹Ÿæ‰¾åˆ°äº†è¿™æ ·ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ£€æµ‹æ‰€æœ‰èŠ‚ç‚¹æ˜¯å¦ä»ç„¶æœ‰æ•ˆï¼Œä¿è¯äº†æ•´ä¸ªé›†ç¾¤ä¸ä¼šå› ä¸ºæŸäº›ç»“ç‚¹çš„å¤±æ•ˆè€Œå‡ºé”™ï¼Œå¢åŠ äº†ä¸€å®šçš„å®¹é”™æ€§ã€‚</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * ping_nodes - check that all nodes and daemons are alive,
 *	get nodes in UNKNOWN state to register
 */</span>
<span class="kt">void</span> <span class="nf">ping_nodes</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">bool</span> <span class="n">restart_flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>	<span class="cm">/* system just restarted */</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* mutex via node table write lock on entry */</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">max_reg_threads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* max node registration threads
					 * this can include DOWN nodes, so
					 * limit the number to avoid huge
					 * communication delays */</span>
</code></pre></div></div>

<h2 id="ray">Ray</h2>

<ul>
  <li><a href="https://github.com/ray-project/ray">ray-project/ray</a></li>
</ul>

<p>Rayæ˜¯UC Berkeley RISELabæ–°æ¨å‡ºçš„é«˜æ€§èƒ½åˆ†å¸ƒå¼æ‰§è¡Œæ¡†æ¶ï¼Œå®ƒä½¿ç”¨äº†å’Œä¼ ç»Ÿåˆ†å¸ƒå¼è®¡ç®—ç³»ç»Ÿä¸ä¸€æ ·çš„æ¶æ„å’Œå¯¹åˆ†å¸ƒå¼è®¡ç®—çš„æŠ½è±¡æ–¹å¼ï¼Œå…·æœ‰æ¯”Sparkæ›´ä¼˜å¼‚çš„è®¡ç®—æ€§èƒ½ã€‚</p>

<p><img src="https://images2018.cnblogs.com/blog/405877/201711/405877-20171126235615625-1165176825.png" alt="Rayæ¶æ„å›¾" /></p>

<p>ä½œä¸ºåˆ†å¸ƒå¼è®¡ç®—ç³»ç»Ÿï¼ŒRayä»æ—§éµå¾ªäº†å…¸å‹çš„Master-Slaveçš„è®¾è®¡ï¼šMasterè´Ÿè´£å…¨å±€åè°ƒå’ŒçŠ¶æ€ç»´æŠ¤ï¼ŒSlaveæ‰§è¡Œåˆ†å¸ƒå¼è®¡ç®—ä»»åŠ¡ã€‚ä¸è¿‡å’Œä¼ ç»Ÿçš„åˆ†å¸ƒå¼è®¡ç®—ç³»ç»Ÿä¸åŒçš„æ˜¯ï¼ŒRayä½¿ç”¨äº†æ··åˆä»»åŠ¡è°ƒåº¦çš„æ€è·¯ã€‚åœ¨é›†ç¾¤éƒ¨ç½²æ¨¡å¼ä¸‹ï¼ŒRayå¯åŠ¨äº†ä»¥ä¸‹å…³é”®ç»„ä»¶ï¼š</p>

<ol>
  <li>GlobalSchedulerï¼šMasterä¸Šå¯åŠ¨äº†ä¸€ä¸ªå…¨å±€è°ƒåº¦å™¨ï¼Œç”¨äºæ¥æ”¶æœ¬åœ°è°ƒåº¦å™¨æäº¤çš„ä»»åŠ¡ï¼Œå¹¶å°†ä»»åŠ¡åˆ†å‘ç»™åˆé€‚çš„æœ¬åœ°ä»»åŠ¡è°ƒåº¦å™¨æ‰§è¡Œã€‚</li>
  <li>RedisServerï¼šMasterä¸Šå¯åŠ¨äº†ä¸€åˆ°å¤šä¸ªRedisServerç”¨äºä¿å­˜åˆ†å¸ƒå¼ä»»åŠ¡çš„çŠ¶æ€ä¿¡æ¯ï¼ˆControlStateï¼‰ï¼ŒåŒ…æ‹¬å¯¹è±¡æœºå™¨çš„æ˜ å°„ã€ä»»åŠ¡æè¿°ã€ä»»åŠ¡debugä¿¡æ¯ç­‰ã€‚</li>
  <li>LocalSchedulerï¼šæ¯ä¸ªSlaveä¸Šå¯åŠ¨äº†ä¸€ä¸ªæœ¬åœ°è°ƒåº¦å™¨ï¼Œç”¨äºæäº¤ä»»åŠ¡åˆ°å…¨å±€è°ƒåº¦å™¨ï¼Œä»¥åŠåˆ†é…ä»»åŠ¡ç»™å½“å‰æœºå™¨çš„Workerè¿›ç¨‹ã€‚</li>
  <li>Workerï¼šæ¯ä¸ªSlaveä¸Šå¯ä»¥å¯åŠ¨å¤šä¸ªWorkerè¿›ç¨‹æ‰§è¡Œåˆ†å¸ƒå¼ä»»åŠ¡ï¼Œå¹¶å°†è®¡ç®—ç»“æœå­˜å‚¨åˆ°ObjectStoreã€‚</li>
  <li>ObjectStoreï¼šæ¯ä¸ªSlaveä¸Šå¯åŠ¨äº†ä¸€ä¸ªObjectStoreå­˜å‚¨åªè¯»æ•°æ®å¯¹è±¡ï¼ŒWorkerå¯ä»¥é€šè¿‡å…±äº«å†…å­˜çš„æ–¹å¼è®¿é—®è¿™äº›å¯¹è±¡æ•°æ®ï¼Œè¿™æ ·å¯ä»¥æœ‰æ•ˆåœ°å‡å°‘å†…å­˜æ‹·è´å’Œå¯¹è±¡åºåˆ—åŒ–æˆæœ¬ã€‚ObjectStoreåº•å±‚ç”±Apache Arrowå®ç°ã€‚</li>
  <li>Plasmaï¼šæ¯ä¸ªSlaveä¸Šçš„ObjectStoreéƒ½ç”±ä¸€ä¸ªåä¸ºPlasmaçš„å¯¹è±¡ç®¡ç†å™¨è¿›è¡Œç®¡ç†ï¼Œå®ƒå¯ä»¥åœ¨Workerè®¿é—®æœ¬åœ°ObjectStoreä¸Šä¸å­˜åœ¨çš„è¿œç¨‹æ•°æ®å¯¹è±¡æ—¶ï¼Œä¸»åŠ¨æ‹‰å–å…¶å®ƒSlaveä¸Šçš„å¯¹è±¡æ•°æ®åˆ°å½“å‰æœºå™¨ã€‚</li>
</ol>

<p><strong>Rayå±äºæ··åˆç»„ç»‡ç»“æ„ã€‚</strong></p>

<p>ä»¥ä¸‹ä»£ç ç‰‡æ®µæ¥è‡ªäº<a href="https://github.com/ray-project/ray/blob/master/src/ray/raylet/scheduling_policy.cc">ray/src/ray/raylet/scheduling_policy.cc</a></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">SchedulingPolicy</span><span class="o">::</span><span class="n">SpillOver</span><span class="p">(</span>
    <span class="n">SchedulingResources</span> <span class="o">&amp;</span><span class="n">remote_scheduling_resources</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// The policy decision to be returned.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">decision</span><span class="p">;</span>

  <span class="n">ResourceSet</span> <span class="n">new_load</span><span class="p">(</span><span class="n">remote_scheduling_resources</span><span class="p">.</span><span class="n">GetLoadResources</span><span class="p">());</span>

  <span class="c1">// Check if we can accommodate infeasible tasks.</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">task</span> <span class="o">:</span> <span class="n">scheduling_queue_</span><span class="p">.</span><span class="n">GetTasks</span><span class="p">(</span><span class="n">TaskState</span><span class="o">::</span><span class="n">INFEASIBLE</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">spec</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">GetTaskSpecification</span><span class="p">();</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">placement_resources</span> <span class="o">=</span> <span class="n">spec</span><span class="p">.</span><span class="n">GetRequiredPlacementResources</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">placement_resources</span><span class="p">.</span><span class="n">IsSubset</span><span class="p">(</span><span class="n">remote_scheduling_resources</span><span class="p">.</span><span class="n">GetTotalResources</span><span class="p">()))</span> <span class="p">{</span>
      <span class="n">decision</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">spec</span><span class="p">.</span><span class="n">TaskId</span><span class="p">());</span>
      <span class="n">new_load</span><span class="p">.</span><span class="n">AddResources</span><span class="p">(</span><span class="n">spec</span><span class="p">.</span><span class="n">GetRequiredResources</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Try to accommodate up to a single ready task.</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">task</span> <span class="o">:</span> <span class="n">scheduling_queue_</span><span class="p">.</span><span class="n">GetTasks</span><span class="p">(</span><span class="n">TaskState</span><span class="o">::</span><span class="n">READY</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">spec</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">GetTaskSpecification</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spec</span><span class="p">.</span><span class="n">IsActorTask</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// Make sure the node has enough available resources to prevent forwarding cycles.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">spec</span><span class="p">.</span><span class="n">GetRequiredPlacementResources</span><span class="p">().</span><span class="n">IsSubset</span><span class="p">(</span>
              <span class="n">remote_scheduling_resources</span><span class="p">.</span><span class="n">GetAvailableResources</span><span class="p">()))</span> <span class="p">{</span>
        <span class="n">decision</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">spec</span><span class="p">.</span><span class="n">TaskId</span><span class="p">());</span>
        <span class="n">new_load</span><span class="p">.</span><span class="n">AddResources</span><span class="p">(</span><span class="n">spec</span><span class="p">.</span><span class="n">GetRequiredResources</span><span class="p">());</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">remote_scheduling_resources</span><span class="p">.</span><span class="n">SetLoadResources</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_load</span><span class="p">));</span>

  <span class="k">return</span> <span class="n">decision</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>å¯ä»¥å‘ç°ï¼Œå½“æœ‰æ–°çš„æœåŠ¡å™¨/WorkeråŠ å…¥æ—¶ï¼Œå¾ˆå®¹æ˜“åœ¨new_loadä¸­é€šè¿‡AddResourceæ·»åŠ æ–°çš„workerï¼Œå¯æ‰©å±•æ€§å¾ˆå¥½ã€‚</p>

<p>åŒæ—¶ï¼Œä¹Ÿåœ¨<a href="https://github.com/ray-project/ray/blob/master/src/ray/raylet/node_manager.cc">ray/src/ray/raylet/node_manager.cc</a>çš„1477è¡Œå¤„æ‰¾åˆ°äº†ä¸€äº›å¤„ç†ä»»åŠ¡å¤±è´¥çš„å‡½æ•°ï¼Œè¡¨ç°äº†è¿™ä¸ªç³»ç»Ÿçš„å®¹é”™æ€§ï¼š</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">NodeManager</span><span class="o">::</span><span class="n">TreatTaskAsFailed</span><span class="p">(</span><span class="k">const</span> <span class="n">Task</span> <span class="o">&amp;</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="n">ErrorType</span> <span class="o">&amp;</span><span class="n">error_type</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">TaskSpecification</span> <span class="o">&amp;</span><span class="n">spec</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">GetTaskSpecification</span><span class="p">();</span>
  <span class="n">RAY_LOG</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Treating task "</span> <span class="o">&lt;&lt;</span> <span class="n">spec</span><span class="p">.</span><span class="n">TaskId</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" as failed because of error "</span>
                 <span class="o">&lt;&lt;</span> <span class="n">ErrorType_Name</span><span class="p">(</span><span class="n">error_type</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"."</span><span class="p">;</span>
  <span class="c1">// If this was an actor creation task that tried to resume from a checkpoint,</span>
  <span class="c1">// then erase it here since the task did not finish.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">spec</span><span class="p">.</span><span class="n">IsActorCreationTask</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">ActorID</span> <span class="n">actor_id</span> <span class="o">=</span> <span class="n">spec</span><span class="p">.</span><span class="n">ActorCreationId</span><span class="p">();</span>
    <span class="n">checkpoint_id_to_restore_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">actor_id</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Loop over the return IDs (except the dummy ID) and store a fake object in</span>
  <span class="c1">// the object store.</span>
  <span class="kt">int64_t</span> <span class="n">num_returns</span> <span class="o">=</span> <span class="n">spec</span><span class="p">.</span><span class="n">NumReturns</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">spec</span><span class="p">.</span><span class="n">IsActorCreationTask</span><span class="p">()</span> <span class="o">||</span> <span class="n">spec</span><span class="p">.</span><span class="n">IsActorTask</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// TODO(rkn): We subtract 1 to avoid the dummy ID. However, this leaks</span>
    <span class="c1">// information about the TaskSpecification implementation.</span>
    <span class="n">num_returns</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Determine which IDs should be marked as failed.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">plasma</span><span class="o">::</span><span class="n">ObjectID</span><span class="o">&gt;</span> <span class="n">objects_to_fail</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_returns</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">objects_to_fail</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">spec</span><span class="p">.</span><span class="n">ReturnId</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">ToPlasmaId</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="n">JobID</span> <span class="n">job_id</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">GetTaskSpecification</span><span class="p">().</span><span class="n">JobId</span><span class="p">();</span>
  <span class="n">MarkObjectsAsFailed</span><span class="p">(</span><span class="n">error_type</span><span class="p">,</span> <span class="n">objects_to_fail</span><span class="p">,</span> <span class="n">job_id</span><span class="p">);</span>
  <span class="n">task_dependency_manager_</span><span class="p">.</span><span class="n">TaskCanceled</span><span class="p">(</span><span class="n">spec</span><span class="p">.</span><span class="n">TaskId</span><span class="p">());</span>
  <span class="c1">// Notify the task dependency manager that we no longer need this task's</span>
  <span class="c1">// object dependencies. TODO(swang): Ideally, we would check the return value</span>
  <span class="c1">// here. However, we don't know at this point if the task was in the WAITING</span>
  <span class="c1">// or READY queue before, in which case we would not have been subscribed to</span>
  <span class="c1">// its dependencies.</span>
  <span class="n">task_dependency_manager_</span><span class="p">.</span><span class="n">UnsubscribeGetDependencies</span><span class="p">(</span><span class="n">spec</span><span class="p">.</span><span class="n">TaskId</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>
:ET